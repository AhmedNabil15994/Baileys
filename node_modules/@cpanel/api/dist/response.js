// MIT License
//
// Copyright 2021 cPanel L.L.C.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
import isUndefined from "lodash/isUndefined";
import isNull from "lodash/isNull";
/**
 * Types of message that can be in a response.
 */
export var MessageType;
(function (MessageType) {
    /**
     * Message is an error.
     */
    MessageType[MessageType["Error"] = 0] = "Error";
    /**
     * Message is a warning.
     */
    MessageType[MessageType["Warning"] = 1] = "Warning";
    /**
     * Message is informational.
     */
    MessageType[MessageType["Information"] = 2] = "Information";
    /**
     * The message type is unknown.
     */
    MessageType[MessageType["Unknown"] = 3] = "Unknown";
})(MessageType || (MessageType = {}));
;
export let DefaultMetaData = {
    isPaged: false,
    isFiltered: false,
    record: 0,
    page: 0,
    pageSize: 0,
    totalRecords: 0,
    totalPages: 0,
    recordsBeforeFilter: 0,
    batch: false,
    properties: {},
};
/**
 * Deep cloning of a object to avoid reference overwritting.
 *
 * @param data Metadata object to be cloned.
 * @returns Cloned Metadata object.
 */
function clone(data) {
    return JSON.parse(JSON.stringify(data));
}
/**
 * Base class for all response. Must be sub-classed by a real implementation.
 */
export class Response {
    /**
     * Build a new response object from the response. Note, this class should not be called
     * directly.
     * @param response Complete data passed from the server. Probably it's been parsed using JSON.parse().
     * @param options for how to handle the processing of the response data.
     */
    constructor(response, options) {
        /**
          * The status code returned by the API. Usually 1 for success, 0 for failure.
          */
        this.status = 0;
        /**
          * List of messages related to the response.
          */
        this.messages = [];
        /**
          * Additional data returned about the request. Paging, filtering, and maybe other custom properties.
          */
        this.meta = clone(DefaultMetaData);
        /**
          * Options about how to handle the response processing.
          */
        this.options = {
            keepUnprocessedResponse: false
        };
        if (isUndefined(response) || isNull(response)) {
            throw new Error("The response was unexpectedly undefined or null");
        }
        if (options) {
            this.options = options;
        }
        if (this.options.keepUnprocessedResponse) {
            this.raw = JSON.parse(JSON.stringify(response)); // deep clone
        }
    }
    /**
     * Checks if the API was successful.
     *
     * @return true if successful, false if failure.
     */
    get success() {
        return this.status > 0;
    }
    /**
     * Checks if the api failed.
     *
     * @return true if the API reports failure, false otherwise.
     */
    get failed() {
        return this.status === 0;
    }
    /**
     * Get the list of messages based on the requested type.
     *
     * @param type Type of the message to look up.
     * @return List of messages that match the filter.
     */
    _getMessages(type) {
        return this.messages.filter((message) => message.type === type);
    }
    /**
     * Get the list of error messages.
     *
     * @return List of errors.
     */
    get errors() {
        return this._getMessages(MessageType.Error);
    }
    /**
     * Get the list of warning messages.
     *
     * @return List of warnings.
     */
    get warnings() {
        return this._getMessages(MessageType.Warning);
    }
    /**
     * Get the list of informational messages.
     *
     * @return List of informational messages.
     */
    get infoMessages() {
        return this._getMessages(MessageType.Information);
    }
    /**
     * Checks if there are any messages of a given type.
     * @param type Type of the message to check for.
     * @return true if there are messages of the requested type. false otherwise.
     */
    _hasMessages(type) {
        return this.messages.filter((message) => message.type === type).length > 0;
    }
    /**
     * Checks if there are any error messages in the response.
     *
     * @return true if there are error messages, false otherwise.
     */
    get hasErrors() {
        return this._hasMessages(MessageType.Error);
    }
    /**
     * Checks if there are any warnings in the response.
     *
     * @return true if there are warnings, false otherwise.
     */
    get hasWarnings() {
        return this._hasMessages(MessageType.Warning);
    }
    /**
     * Checks if there are any informational messages in the response.
     *
     * @return true if there are informational messages, false otherwise.
     */
    get hasInfoMessages() {
        return this._hasMessages(MessageType.Information);
    }
    /**
     * Check if the response was paginated by the backend.
     *
     * @return true if the backend returned a page of the total records.
     */
    get isPaged() {
        return this.meta.isPaged;
    }
    /**
     * Check if the response was filtered by the backend.
     *
     * @return true if the backend filtered the records.
     */
    get isFiltered() {
        return this.meta.isFiltered;
    }
}
//# sourceMappingURL=response.js.map